# Deep Dive ch.2~ch.5

# 자바스크립트

## 자바스크립트의 표준화 

- 마이크로소프트 (JScript) & 넷스케이프 커뮤니케이션즈(Javascript) 는 자사 브라우저의 시장 점유율 높이기 위해 자사 브라우저에서만 동작하는 기능을 추가하기 시작함으로써 <b>크로스 브라우징 이슈</b>가 생김

- 이에 넷스케이프 커뮤니케이션즈는 컴퓨터 시스템의 표준을 관리하는 비영리 표준화 기구인 ECMA 인터네셔널에 자바스크립트 표준화를 요청

- 현재는 ECMAScript 3이 이후에 공개되어지고, 10년만에 ECMAScript 5와 html/css 5와 함께 출현한 표준 사양

- ES6 이후의 버전은 비교적 작은 기능을 추가하는 수준 ( let, const 키워드 / 화살표 함수 / 클래스/ 모듈 등)

## 자바스크립트 성장의 역사

- 초창기 : 웹페이지의 보조적인 기능을 수행하기 위한 용도(웹서버에 실행 + 브라우저는 서버로부터 전달받은 HTML과 CSS를 렌더링)

### Ajax

- 1999년, 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 기능 둠

- 이전 : html태그로 시작해서 html 태그로 끝나는 완전한 html 코드를 서버로부터 전송받아 웹페이지 전체를 렌더링 하는 방식으로 동작 -> 화면이 전환되면 서버로부터 새로운 html을 전송받아 웹페이지 전체를 다시 렌더링

- Ajax : 필요한 부분만 데이터를 전송받아 렌더링이 가능해짐  => 브라우저에서도 웹 app과 유사한 빠른 성능과 부드러운 화면 전환이 가능해짐

- 2005년, JS와 Ajax를 사용해 웹 브라우저에서도 좋은 성능과 부드러운 화면 전환 효과를 보여주며 자바스크립트의 가능성을 확인시켜줌

### jQuery

- DOM을 더욱 쉽게 제어가능하게 됨 + 크로스 브라우징이슈 어느정도 해결 + 자바스크립트보다 직관적

- V8 자바스크립트 엔진의 등장 :

	- 데스크톱 애플리케이션과 웹 애플리케이션의 유사한 사용자 경험(UX)를 제공할 수 있게됨

	- 과거 웹 서버에서 수행되던 로직들이 클라이언트로 이동했고, 웹 앱플리케이션 개발에서 FE가 주목받는 계기가 됨

### Node.js

- 라이언 딜이 발표한 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경

- 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경

- 서버 사이드 애플리케이션 개발에 주로 사용되고 이에 필요한 모듈, 파일 시스템, HTTP 등 빌트인 API 제

- FE와 BE 에서 모두 사용할수 있어 언어를 학습하기 위한 시간은 줄어든다는 장점 존재

- 비동기 I/O를 지원하며 단일 스레드 이벤트 ㅍ루프 기반으로 동작함으로써 요청 처리 성능이 좋다. 

- 데이터를 실시간으로 처리하기위해 I/O가 빈번하게 발생하는 SPA에 적합하지만 CPU 사용률이 높은 app에는 권장하지 않음

- 크로스 플랫폼을 위한 언어로 주목받고있음

### SPA 프레임워크

- 웹과 데스크톱에서 모두 좋은 사용자경험을 제공하는것이 필수가되었고, 개발 규모와 개발과정은 점점 복잡해졌다. 그러면서 많이 사용되는 패턴의 라이브러리가 출현해 개발에 많은 도움을 주었지만, 변경에 유연하면서 확장하기 쉬운 app 아키텍쳐 구축을 어렵게했고 그로 인해 프레임워크가 등장

- SPA 프레임워크/라이브러리 : react, vue, svelte, angular

### ECMAScript & JS

- ECMAScript : 자바스크립트의 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정 

- 각 브라우저 제조사는 ECMAScript 사양을 준수해서 브라우저에 내장되는 자바스크립트 엔진 구현

- 자바 스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대를 이루는 EXMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 web API (DOM, BOM, Canvas, XMLHttpRequest, fetch, SVG, Web Storage등)를 아우르는 개념

- 클라이언트 사이드 Web Api는 ECMAScript와 별개로 웹 콘소시엄에서 별도 사양으로 관리함

### 자바스크립트의 특징

- 웹 브라우저에서 동작하는 유일한 프로그래밍 언어

- 여러가지 언어에서 영향을 받음 (자바, C)

- 인터프리터 언어 : 개발자가 별도의 컴파일 작업을 수행하지 않는 언어

	- 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점 최소화 

- 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다. 

- IE나 구형 브라우저는 ES6를 대부분 지원하지 않아 최신 기능을 사용하거나 IE나 구형 브라우저를 고려해야하는 상황이라면 바벨과 같은 트랜스파일러를 사용해 ES6이상의 사양으로 구현한 소스코드를 ES5이하의 사양으로 다운그래이드할 필요가 있음

## CH.3 자바스크립트 실행 환경

- 자바스크립트는 브라우저에서 작동하는 언어 / node.js는 js를 브라우저 외에서도 작동하게하는 런타임 환

- 모든 브라우저는 자바스크립트를 해석하고 실행할 수 있는 자바스크립트 엔진을 내장하고 있음 

- 다만 node.js와 브라우저는 다름 

	- 브라우저 : html, css, js를 실행해 웹 페이지를 브라우저 화면에 렌더링하는것이 주 목적

	- node.js : 브라우저 외부에서 자바스크립트 실행 환경을 제공하는 것이 주 목적

	- 공통점
		브라우저와 node.js 모두 js 코어 EXMAScript를 실행가능하지만 그것 이외에 추가로 제공하는 기능은 호환이 어려움

	-  차이점

		브라우저는 파싱된 html요소를 선택하거나 조작하는 기능의 집합인 DOM API를 기본적으로 제공하지만 node.js는 dom api를 제공하지 않는다 (브라우저 외부 환경에서는 html요소를 파싱해서 객체화한 dom을 직접 다룰 필요가 없기때문)
	
		node.js는 파일을 생성, 수정할 수 있는 파일 시스템을 기본 제공하지만 브라우저는 지원하지 않아 Web API인 FileReader 객체를 사용해 사용자가 지정한 파일을 읽어드릴수는 있다. 
		

		웹 앱 자바스크립트는 사용자의 컴퓨터 브라우저에서 작동하는데 브라우저 환경의 자바스크립트 파일은 제공되지 않는다 (이 파일을 다운받아 수정 및 삭제한다면 악성코드에 노출되는것이라 보안상의 문제로)

### 개발자 도구

- 맥 : cmd + opt + I 

- 윈도우 : F12 or Ctrl+shift+I

- Element : 로딩된 웹페이지의 DOM과 CSS를 편집해서 렌더링된 뷰를 확인가능

- Console : 로딩된 웹페이지의 에러를 확인하거나 JS 소스코드에 작성한 console.log 메서드의 실행 결과를 확인할 수 있다. 

- Network : 로딩된 웹페이지에 관련된 네트워크 요청 정보와 성능 확인 가능

- Sources : 로딩된 웹페이지의 자바스크립트 코드를 디버깅 가능

- Application : 웹스토리지, 세션, 쿠키 확인하고 관리 

-  웹크롤링 : 서버에서 웹사이트의 필요한 콘텐츠만 수집해 이를 가공해서 필요한 데이터만 추출 (dom 라이브러리를 사용해서 html 문서를 가공하기도 한다)

### Node.js

- 클라이언트 사이드에서 간단하게 동작하는 웹 앱 개발은 브라우저에서도 가능하지만 규모가 커지면 프레임워크나 라이브러리 도입하거나 Babel, ESLint, Webpack 등 여러가지 도구 사용 가능 -> Node.js와 npm이 필요

- 브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작시킬수 있는 자바스크립트 환경

- npm은 자바스크립트 패키지 매니저 (node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI 제공) -> 패키지 공개 및 재사용 가능

- npm 

	- LTS(Long Term Support) : 장기적으로 안정된 지원이 보장됨
	
	- Current : 최신 기능제공하지만, 안정적이지 않을 수 있다. 

- REPL(Read Eval Print Loop) 

	- 자바스크립트 코드를 실행해 결과를 확인가능하게해줌

## CH.4 변수

### 변수란?

- 변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념

- 자바스크립트 엔진(V8)이 위 자바스크립트 코드를 계산하려면 리터럴과 연산자의 의미를 알고있어야하며 표현식의 의미도 해석해야한다. 

- 컴퓨터는 CPU를 사용해서 연산하고, 메모리를 사용해 데이터를 기억한다. (임이의 위치(메모리 주소)에 기억되고 CPU는 이 값을 읽어 연산을 수행한다)

	- CPU : 계산하는 장치 (M1칩)

	- 메모리 : 데이터를 저장할 수 있는 메모리 셀의 집합체 (셀 하나의 크기는 1바이트 -> 8기가램) 

		- 1바이트 단위로 데이터를 저장하거나 읽음

		- 각 셀은 고유의 메모리 주소를 갖고, 이 주소는 메모리 공간의 위치를 나타낸다. (메모리 크기만큼 정수로 표현됨)

- 연산 결과를 단 한번만 사용한다면 문제가 없지만 만약 결과를 재사용하고싶다면 메모리 주소를 통해 연산 결과에 직접 접근하는 것은 치명적인 오류를 발생시킬 수 있다 (이 방법 외엔 방법이 없음) -> 그래서 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않

	- 잘못 접근해서 다른 주소에 찾아가 다른 정보를 변경하는 것에 치명적인 어려움

	- 어떤 정보인지, 주소(숫자로 이루어짐)가 하나라도 틀리면 이상한곳에 가게됨 

- 그래서 변수에 기억하고싶은 값을 메모리에 저장하고 저장된 값을 읽어들여 재사용할 수 있도록 매커니즘을 제공.  (하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름)
		- 컴퓨터는 데이터의 종류에 상관없이 모두 2진수로 저장된다 

- 변수에 값을 할당하면 가독성을 높일수도 있고 어떤 역할을 하는지 알기도 쉽다. 

### 식별자 

- 어떤 값을 구별해서 식별할 수 있는 고유한 이름 ( 값은 메모리 공간에 저장되어있음)

- 즉, 값이 저장되어있는 메모리 주소와 매핑관계를 맺으며 이 매핑 정보도 메모리에 저장되어야 한다. 

- 식별자는 값이 아니라 메모리 주소를 기억하고 있다. (변수, 함수, 클래스 이름 모두 식별자)

### 변수 선언

- 값을 저장하기 위해 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연

- 변수 선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다. 

- 변수 선언시 var,let,const를 사용하는데 ES6이전에는 var만 존재했다. 

	- ES5 vs ES6 : var 키워드 / 블록 레벨 스코프를 지원하지않고 함수 레벨 스코프 지원 (전역 변수가 선언되어 심각한 부작용 발생)

	- var을 권장하지는 않지만 폐기되지는 않아 사용가능함 (ES6는 ES5의 상위 집합)

- 변수 선언시 값을 할당하지 않으면 undefined라는 값이 암묵적으로 할당되어 초기화한다. 

- 자바 스크립트는 두 단계의 과정을 거침 (선언 단계, 초기화 단계) -> 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 app에서 사용했던 값이 남아있을 수 있다. (=쓰레기값), var 키워드는 암묵적으로 초기화를 수행해 이런 위험으로부터 안전함

### 변수 선언의 실행 시점과 변수 호이스팅

- 인터프리터에 의해 한 줄씩 순차적으로 실행되는 시점 = 런타임

- 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드를 평가 과정을 거치며 소스코드를 실행하기 위한 준비를 하고, 이 때 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행한다. 그 소소코드 평가 과정이 끝나면 소스코드를 한 줄씩 순차적으로 실행한다. 

- 변수 호이스팅 : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

### 값의 할당 

- 변수에 값을 할당할때는 이전값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장한다는점에 주의하기 

- var : 키워드로 선언한 변수는 값을 재할당할 수 있다. 

- const : 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다. 

	- 가비지 콜렉터 : 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. (어떤 식별자도 참조하지 않는 메모리 공간) -> 누수 방지

- 언매니지드 언어와 매니지드 언어 :

	- 메모리 관리 방식에 따라 나뉨

	- C 언어 같은 언매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 저수준 메모리 제어 기능을 제공 ( 개발자가 메모리 제어 주도할 수 있으며 역량에 따라 최적의 성능을 확보하거나 치명적 오류를 생산 가능)

	- 자바스크립트는 매니지드 언어기 때문에 메모리 할당 및 해제를 위한 메모리 관리는 언어 차원에서 관리. 즉 더 이상 사용하지 않는 메모리의 해제는 가비지 콜렉터가 수행하며 이 또한 개발자가 관여할 수 없다. 개발자의 역량에 의존하는부분이 적어 일정한 생산성 확보가능하지만 성능면에서 손실 가능

	- 그렇기때문에 undefined에 값을 재할당하는것이 아니라 새로운 공간에 값을 재할당함 (과정도 단순하고 그래야 값을 더 안전하게 저장 가능하기때문에)

### 식별자 네이밍 규칙

	- 식별자는 숫자로 시작할 수 없고, 하이픈은 사용 불가 (즉, 케밥 케이스 사용불가)

	- 코드 전체의 가독성을 높이기 위해서는 카멜 케이스와 파스칼 케이스를 따르는 것이 유리

## 표현식

- 값은 식이 평가되어 생성된 결과를 말함 (변수에 할당되는 것은 10+20이 아니라 30이라는 결과임)

### 리터럴

- 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

- 예시) 100, o*41, [1,2,3]

### 표현식 

- 값으로 평가될수있는 statement (표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조)

- 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조한다. (값으로 평가될 수 있는 문은 모두 표현식)

### 문

- 문 statement : 프로그램을 구성하는 기본 단위이자 최소 실행 단위 (=명령문)

	- 여러 토큰으로 구성되어있음 (토큰 = 문법적인 의미를 가지며 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소 => 연산자, 리터럴, 세미콜론, 마침표 등) 

	- 선언문, 할당문, 조건문, 반복문 등으로 구분 가

	- 변수 선언문 (변수 선언), 할당문 (값이 할당), 조건문(조건에 따라 코드 블록이 결정되어 실행됨), 반복문(특정 코드 블록이 반복 실행)

### 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론 : 종료를 의미 

- 세미콜론은 생략이 가능함 (세미콜론 자동 삽입 기능이 암묵적으로 수행되기때문) 

- 하지만 자동 삽입 기능과 개발자 사라의 예측이 일치하지 않는 경우도 존재 

### 표현식 문과 표현식이 아닌 문

- 표현식 문 : 값으로 평가될 수 있는 문 (var x=100;)

- 표현식이 아닌 문 : 값으로 평가될 수 없는 문 ( 값으로 평가할 수 없으므로 변수에 할당하면 에러가 난다)

